/**
 * Node System - Foundation for Infinite Complexity
 *
 * Architecture:
 * - Generator nodes: Create base visual patterns
 * - Effect nodes: Transform and enhance visuals
 * - Composition nodes: Combine multiple layers
 * - Control params: Audio-reactive or evolving parameters
 *
 * The AI orchestrator commands these nodes to create 100+ unique visual states
 */

import { DeepAudioFeatures } from '../deep-audio-analyzer.js';

/**
 * Control Parameter - Can be static, evolving, or audio-reactive
 */
export interface ControlParam {
  type: 'static' | 'evolving' | 'audio-reactive';

  // Static value
  value?: number;

  // Evolving parameters
  startValue?: number;
  endValue?: number;
  curve?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'sine' | 'bounce';

  // Audio-reactive parameters
  audioSource?: AudioSource;
  audioRange?: [number, number]; // Map audio feature to this range
  smoothing?: number; // 0-1, how much to smooth audio reactivity
}

/**
 * Audio sources that can drive parameters
 */
export type AudioSource =
  | { type: 'rms' } // Overall energy
  | { type: 'bass' } // 20-250 Hz
  | { type: 'mid' } // 500-2000 Hz
  | { type: 'high' } // 4000-20000 Hz
  | { type: 'spectralCentroid' } // Brightness
  | { type: 'spectralFlux' } // Rate of change (onsets)
  | { type: 'beat'; confidence?: number } // Beat detection
  | { type: 'mfcc'; coefficient: number } // Timbre (0-12)
  | { type: 'chroma'; note: number }; // Pitch class (0-11)

/**
 * Base Node interface
 */
export interface Node {
  id: string;
  type: 'generator' | 'effect' | 'composition';
  enabled: boolean;

  // Time range this node is active (seconds)
  startTime: number;
  endTime: number;

  // Fade in/out (seconds)
  fadeIn?: number;
  fadeOut?: number;

  // Parameters controlled by AI orchestrator
  params: Record<string, any>;
}

/**
 * Generator Node - Creates base visual patterns
 */
export interface GeneratorNode extends Node {
  type: 'generator';
  generator: GeneratorType;
}

export type GeneratorType =
  | { name: 'perlin-noise'; octaves: ControlParam; scale: ControlParam; speed?: ControlParam; }
  | { name: 'particles'; count: ControlParam; size: ControlParam; speed: ControlParam; }
  | { name: 'fractal'; iterations: ControlParam; zoom: ControlParam; }
  | { name: 'voronoi'; points: ControlParam; distance: ControlParam; }
  | { name: 'flow-field'; resolution: ControlParam; strength: ControlParam; speed?: ControlParam; }
  | { name: 'waves'; frequency: ControlParam; amplitude: ControlParam; }
  | { name: 'radial-waves'; frequency: ControlParam; amplitude: ControlParam; speed: ControlParam; }
  | { name: 'geometric'; sides: ControlParam; rotation: ControlParam; scale: ControlParam; }
  | { name: 'solid-color'; color: ControlParam; }
  | { name: 'circles'; count: ControlParam; radius: ControlParam; }
  | { name: 'lines'; count: ControlParam; thickness: ControlParam; }
  | { name: 'grid'; columns: ControlParam; rows: ControlParam; }
  | { name: 'plasma'; complexity: ControlParam; speed: ControlParam; };

/**
 * Effect Node - Transforms visuals
 */
export interface EffectNode extends Node {
  type: 'effect';
  effect: EffectType;
}

export type EffectType =
  | { name: 'blur'; radius: ControlParam; }
  | { name: 'bloom'; threshold: ControlParam; intensity: ControlParam; }
  | { name: 'kaleidoscope'; segments: ControlParam; rotation: ControlParam; }
  | { name: 'color-grade'; hue: ControlParam; saturation: ControlParam; brightness: ControlParam; }
  | { name: 'feedback'; amount: ControlParam; decay: ControlParam; }
  | { name: 'displacement'; strength: ControlParam; scale: ControlParam; }
  | { name: 'chromatic-aberration'; amount: ControlParam; }
  | { name: 'grain'; amount: ControlParam; }
  | { name: 'vignette'; intensity: ControlParam; }
  | { name: 'pixelate'; size: ControlParam; }
  | { name: 'edge-detect'; threshold: ControlParam; };

/**
 * Composition Node - Combines multiple layers
 */
export interface CompositionNode extends Node {
  type: 'composition';
  composition: CompositionType;
}

export type CompositionType =
  | { name: 'blend'; mode: 'add' | 'multiply' | 'screen' | 'overlay'; opacity: ControlParam; }
  | { name: 'mask'; sourceNode: string; maskNode: string; }
  | { name: 'layer'; zIndex: ControlParam; };

// Union type for all node types
export type VisualNode = GeneratorNode | EffectNode | CompositionNode;

/**
 * Visual Timeline - Complete description of visual states
 * Generated by AI orchestrator based on audio features
 */
export interface VisualTimeline {
  duration: number; // Total duration in seconds
  nodes: Node[]; // All nodes in the timeline

  // Global parameters
  backgroundColor: ControlParam;

  // Metadata
  musicGenre?: string;
  mood?: string;
  energy?: 'low' | 'medium' | 'high';
}

/**
 * Node Renderer Context - State passed to node renderers
 */
export interface NodeRenderContext {
  // Current time
  time: number;
  deltaTime: number;
  frame: number;

  // Audio features at current time
  audioFeatures: DeepAudioFeatures;
  audioFrame: number; // Index into 30fps audio arrays

  // WebGL context
  gl: any; // WebGL context (from headless-gl)

  // Framebuffers
  inputBuffer: any; // Input texture (for effects)
  outputBuffer: any; // Output texture

  // Canvas dimensions
  width: number;
  height: number;
}

/**
 * Evaluate a control parameter at current time/audio state
 */
export function evaluateParam(
  param: ControlParam,
  time: number,
  duration: number,
  audioFeatures: DeepAudioFeatures,
  audioFrame: number
): number {
  switch (param.type) {
    case 'static':
      return param.value ?? 0;

    case 'evolving': {
      const progress = time / duration;
      const start = param.startValue ?? 0;
      const end = param.endValue ?? 1;
      const curve = param.curve ?? 'linear';

      let t = progress;
      switch (curve) {
        case 'ease-in': t = t * t; break;
        case 'ease-out': t = 1 - (1 - t) * (1 - t); break;
        case 'sine': t = Math.sin(t * Math.PI / 2); break;
        case 'bounce': t = Math.sin(t * Math.PI * 4) * (1 - t) + t; break;
      }

      return start + (end - start) * t;
    }

    case 'audio-reactive': {
      if (!param.audioSource) return 0;

      let rawValue = 0;
      const source = param.audioSource;

      // Extract audio value at current frame
      if (audioFrame < 0) return 0;

      switch (source.type) {
        case 'rms':
          rawValue = audioFeatures.rms[audioFrame] ?? 0;
          break;
        case 'bass':
          rawValue = audioFeatures.bass[audioFrame] ?? 0;
          break;
        case 'mid':
          rawValue = audioFeatures.mid[audioFrame] ?? 0;
          break;
        case 'high':
          rawValue = audioFeatures.high[audioFrame] ?? 0;
          break;
        case 'spectralCentroid':
          rawValue = audioFeatures.spectralCentroid[audioFrame] ?? 0;
          break;
        case 'spectralFlux':
          rawValue = audioFeatures.spectralFlux[audioFrame] ?? 0;
          break;
        case 'beat': {
          // Find closest beat within 0.1s
          const currentTime = audioFrame / 30; // 30fps
          const closestBeat = audioFeatures.beats.find(
            b => Math.abs(b.time - currentTime) < 0.1
          );
          rawValue = closestBeat ? closestBeat.confidence : 0;
          break;
        }
        case 'mfcc':
          rawValue = audioFeatures.mfcc[audioFrame]?.[source.coefficient] ?? 0;
          break;
        case 'chroma':
          rawValue = audioFeatures.chroma[audioFrame]?.[source.note] ?? 0;
          break;
      }

      // Apply smoothing (simple exponential moving average)
      // Note: This is a simplified smoothing. For proper smoothing, we'd need to maintain state
      // For now, just use the raw value without recursion

      // Map to target range
      const [min, max] = param.audioRange ?? [0, 1];
      return min + rawValue * (max - min);
    }
  }
}

/**
 * Calculate node opacity based on fade in/out
 */
export function calculateNodeOpacity(node: Node, time: number): number {
  if (!node.enabled) return 0;
  if (time < node.startTime || time > node.endTime) return 0;

  let opacity = 1;

  // Fade in
  if (node.fadeIn && time < node.startTime + node.fadeIn) {
    opacity = (time - node.startTime) / node.fadeIn;
  }

  // Fade out
  if (node.fadeOut && time > node.endTime - node.fadeOut) {
    opacity = (node.endTime - time) / node.fadeOut;
  }

  return Math.max(0, Math.min(1, opacity));
}
